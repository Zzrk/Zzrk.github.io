# 执行上下文、作用域、闭包

[执行上下文和执行栈](https://juejin.cn/post/6844903682283143181)

- 全局执行上下文
- 函数执行上下文
- Eval 函数执行上下文

当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。
执行上下文的两个阶段

1. 创建阶段
- this 绑定
- 创建词法环境组件（函数声明以及let 和 const 等）
   - 环境记录器（全局执行上下文中为对象环境记录器，函数执行上下文中为声明式环境记录器）
   - 外部环境的引用
- 创建变量环境组件（var）
2. 执行阶段

完成对所有这些变量的分配，最后执行代码。
在执行阶段，如果 JavaScript 引擎不能在源码中声明的实际位置找到 let 变量的值，它会被赋值为 undefined。

---

[作用域](https://juejin.cn/post/6844903584891420679)

- 全局作用域
- 函数作用域
- 块级作用域
- 词法作用域
- 动态作用域（this）

---

[静态作用域链和动态闭包链](https://juejin.cn/post/6957913856488243237)

闭包是在函数创建的时候，让函数打包带走的根据函数内的外部引用来过滤作用域链剩下的链。它是在函数创建的时候生成的作用域链的子集，是打包的外部环境。evel 因为没法分析内容，所以直接调用会把整个作用域打包（所以尽量不要用 eval，容易在闭包保存过多的无用变量），而不直接调用则没有闭包。

过滤规则：
1. 全局作用域不会被过滤掉，一定包含。所以在何处调用函数都能访问到。
2. 其余作用域会根据是否内部有变量被当前函数所引用而过滤掉一些。不是每个返回的子函数都会生成闭包。
3. 被引用的作用域也会过滤掉没有被引用的 binding （变量声明）。只把用到的变量打个包。

[闭包](https://juejin.cn/post/6937469222251560990)
